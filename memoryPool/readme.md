## 单线程内存池

使用 slab 机制实现

功能点
内存申请和释放
低于指定内存后不进行释放
内存申请信息记录

问题
内存越界之后好像无法处理了
直接使用malloc()申请的内存如何识别呢？
    如果不在我们管理的内存范围内，直接使用free()释放



### 设计思路

两级内存管理

第一级是一个内存池：
功能：
- 从系统申请内存
- 内存池中空闲内存太多的时候将多余的内存还给系统
- 分发内存给下级内存队列

第二级是一个Slab类，这个Slab类管理N个Slot类，每个Slot类管理M个大小相同的内存数组，数组中的每个内存块大小也相同
当某个Slot类内存不够的时候，从内存池申请内存，创建新的内存数组，
当内存管理机构中空闲内存太多的时候，每个Slot将空的内存数组返还给内存池

应用代码申请内存的机制：
应用代码申请的内存大小为size，向上取值找到管理ceil(size)大小内存的Slot类，如果没有找到，说明申请的内存太大，直接使用malloc申请内存给应用代码
从Slot类管理的内存数组中从前往后查找，寻找未被使用的内存块，找到后在位图中将该内存块标记为已使用，然后将该块内存
的地址返回给应用代码

应用代码释放内存的机制
检查应用代码需要free的内存指针，如果不在管理范围内吗，直接free，
如果在管理范围内，找到该段内存所属的Slot，将该段内存标记未使用




FILO数组 + freeNodeNum



## 优化方案
- mmap 每次多申请内存，留着备用
- 给每块内存添加隐藏头，用来存放所属的slot的地址


